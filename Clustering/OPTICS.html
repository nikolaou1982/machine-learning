<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive OPTICS implementation in 2D. Visualize and experiment with this clustering algorithm using real-time charts and data analysis tools.">
  <link rel="canonical" href="https://yourdomain.com/Clustering/OPTICS.html">
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "OPTICS (2D) - Interactive Implementation | Clustering | ML Tools",
  "description": "Interactive OPTICS implementation in 2D. Visualize and experiment with this clustering algorithm using real-time charts and data analysis tools.",
  "url": "https://yourdomain.com/Clustering/OPTICS.html",
  "about": {
    "@type": "Thing",
    "name": "OPTICS",
    "description": "OPTICS algorithm for clustering"
  }
}
  </script>
    <title>OPTICS (2D) - Interactive Implementation | Clustering | ML Tools</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            color: #676767;
            background-color: #1e1e1e;
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 250px;
            background-color: #171717;
            padding: 30px 20px;
            border-right: 1px solid #333;`n            overflow-y: auto;`n            height: 100vh;
        }
        
        .sidebar h1 {
            color: white;
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .nav-section {
            margin-bottom: 30px;
        }
        
        .nav-section h3 {
            color: #dd8448;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        
        .nav-item {
            display: block;
            color: #676767;
            text-decoration: none;
            padding: 12px 15px;
            margin-bottom: 5px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .nav-item:hover {
            background-color: #2d2d2d;
            color: white;
            transform: translateX(5px);
        }
        
        .nav-item.active {
            background-color: #dd8448;
            color: white;
        }
        
        .nav-category {
            margin-bottom: 20px;
        }
        
        .nav-category-header {
            color: #dd8448;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: 1px;
        }
        
        .nav-category-header:hover {
            background-color: #2d2d2d;
        }
        
        .nav-category-header .arrow {
            transition: transform 0.3s ease;
            font-size: 0.7rem;
        }
        
        .nav-category-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .nav-subcategory {
            margin-left: 15px;
            margin-top: 10px;
            overflow: hidden;
            max-height: 1200px;
            transition: max-height 0.3s ease;
        }
        
        .nav-subcategory.collapsed {
            max-height: 0;
        }
        
        .nav-subheader {
            color: #999;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 15px;
            margin-top: 5px;
            letter-spacing: 0.5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }
        
        .nav-subheader:hover {
            background-color: #2d2d2d;
        }
        
        .nav-subheader .arrow {
            font-size: 0.6rem;
            transition: transform 0.3s ease;
        }
        
        .nav-subheader.collapsed .arrow {
            transform: rotate(-90deg);
        }
        
        .nav-subheader.category-header {
            color: #dd8448;
            font-size: 0.85rem;
            font-weight: 700;
            padding: 10px 15px;
            margin-top: 8px;
            letter-spacing: 1px;
            border: 1px solid rgba(221,132,72,0.3);
        }
        
        .nav-subheader.category-header:hover {
            background-color: rgba(221,132,72,0.15);
            border-color: rgba(221,132,72,0.5);
        }
        
        .nav-subgroup {
            overflow: hidden;
            max-height: 200px;
            transition: max-height 0.3s ease;
            padding-bottom: 5px;
        }
        
        .nav-subgroup.collapsed {
            max-height: 0;
        }
        
        .nav-subgroup.category-group {
            max-height: 1000px;
        }
        
        .nav-subgroup.category-group.collapsed {
            max-height: 0;
        }
        
        .nav-subheader.nested {
            margin-left: 10px;
            font-size: 0.7rem;
        }
        
        .nav-subgroup.nested {
            margin-left: 10px;
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding-bottom: 5px;
        }
        
        .nav-subgroup.nested.collapsed {
            max-height: 0;
        }
        
        .nav-subheader.subcategory-header {
            color: #999;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 8px 15px;
            margin-left: 10px;
            margin-top: 5px;
            letter-spacing: 0.5px;
            border: 1px solid rgba(153, 153, 153, 0.2);
        }
        
        .nav-subheader.subcategory-header:hover {
            background-color: rgba(45, 45, 45, 0.5);
            border-color: rgba(153, 153, 153, 0.4);
        }
        
        .nav-subgroup.subcategory-group {
            margin-left: 10px;
            max-height: 800px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding-bottom: 5px;
        }
        
        .nav-subgroup.subcategory-group.collapsed {
            max-height: 0;
        }
        
        .nav-item.sub {
            padding: 8px 15px;
            font-size: 0.9rem;
            margin-left: 10px;
            margin-bottom: 5px;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
        }
        .main-title {
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        .subtitle {
            color: #676767;
            font-size: 1rem;
            margin-bottom: 30px;
            text-align: center;
        }
        .controls-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-group {
            background-color: #171717;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            min-width: 200px;
        }
        
        .control-group h3 {
            color: white;
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        .control-item label {
            display: block;
            color: #676767;
            margin-bottom: 5px;
            font-weight: 500;
        }
        .control-item input, .control-item select {
            width: 100%;
            padding: 8px 12px;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-family: 'Nunito', sans-serif;
        }
        
        .control-item input:focus, .control-item select:focus {
            outline: none;
            border-color: #dd8448;
        }
        
        .btn {
            background-color: #dd8448;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Nunito', sans-serif;
            transition: background-color 0.3s ease;
        }
        
        .btn:hover {
            background-color: #c67339;
        }
        
        .csv-upload {
            position: relative;
            display: inline-block;
        }
        
        .csv-upload input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .csv-upload-label {
            display: inline-block;
            background-color: #2d2d2d;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            border: 2px dashed #444;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .csv-upload-label:hover {
            border-color: #dd8448;
            background-color: #3d3d3d;
        }
        
        :root {
            --electric-border-color: #dd8448;
            --electric-light-color: #ff9f5a;
            --gradient-color: rgba(221, 132, 72, 0.4);
            --color-neutral-900: #2d2d2d;
        }
        
        .control-group.csv-format {
            padding: 2px;
            background: linear-gradient(-30deg, var(--gradient-color), transparent, var(--gradient-color)),
                        linear-gradient(to bottom, var(--color-neutral-900), var(--color-neutral-900));
            position: relative;
        }
        
        .control-group.csv-format::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid rgba(221, 132, 72, 0.5);
            border-radius: 12px;
            pointer-events: none;
        }
        
        .control-group.csv-format::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 1px solid var(--electric-border-color);
            border-radius: 12px;
            pointer-events: none;
        }
        
        .csv-glow-1, .csv-glow-2 {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 12px;
            pointer-events: none;
        }
        .csv-glow-1 { border: 1px solid rgba(221,132,72,0.6); filter: blur(1px); }
        .csv-glow-2 { border: 1px solid var(--electric-light-color); filter: blur(3px); }
        
        .csv-info-card {
            background: #171717;
            border-radius: 10px;
            padding: 16px;
            margin: 2px;
            position: relative;
            z-index: 10;
        }
        .csv-badge {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            color: rgba(255,255,255,0.8);
            width: fit-content;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .csv-title { color: white; font-size: 16px; font-weight: 600; margin: 8px 0 4px 0; }
        .csv-desc { color: rgba(255,255,255,0.6); font-size: 11px; line-height: 1.3; }

        .stats-container {
            background-color: #171717;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            margin-bottom: 30px;
        }
        
        .stats-container h3 {
            color: white;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            color: #dd8448;
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
        }
        
        .stat-label {
            color: #676767;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        .plots-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .plot-wrapper {
            background-color: #171717;
            border-radius: 12px;
            border: 1px solid #333;
            padding: 20px;
            flex: 1;
            min-width: 400px;
        }
        
        .plot-wrapper h3 {
            color: white;
            margin-bottom: 15px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1>ML Tools</h1>
        
        <div class="nav-section">
            <h3>Dashboard</h3>
            <a href="main.html" class="nav-item">Overview</a>
        </div>
        
        <div class="nav-section">
            <h3>Clustering Methods</h3>
            <div class="nav-category">
                <div class="nav-category-header collapsed" onclick="toggleCategory(this)">
                    <span>Density-Based</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="nav-subcategory collapsed">
                    <div class="nav-subheader collapsed" onclick="toggleSubgroup(this)">
                        <span>DBSCAN</span>
                        <span class="arrow">‚ñº</span>
                    </div>
                    <div class="nav-subgroup collapsed">
                        <a href="DBSCAN.html" class="nav-item sub">2D</a>
                        <a href="DBSCAN3D.html" class="nav-item sub">3D</a>
                    </div>
                    
                    <div class="nav-subheader collapsed" onclick="toggleSubgroup(this)">
                        <span>HDBSCAN</span>
                        <span class="arrow">‚ñº</span>
                    </div>
                    <div class="nav-subgroup collapsed">
                        <a href="HierarchicalDBSCAN.html" class="nav-item sub">2D</a>
                        <a href="HierarchicalDBSCAN3D.html" class="nav-item sub">3D</a>
                    </div>
                    
                    <div class="nav-subheader collapsed" onclick="toggleSubgroup(this)">
                        <span>OPTICS</span>
                        <span class="arrow">‚ñº</span>
                    </div>
                    <div class="nav-subgroup collapsed">
                        <a href="OPTICS.html" class="nav-item sub active">2D</a>
                        <a href="OPTICS3D.html" class="nav-item sub">3D</a>
                    </div>
                    
                    <div class="nav-subheader collapsed" onclick="toggleSubgroup(this)">
                        <span>DENCLUE</span>
                        <span class="arrow">‚ñº</span>
                    </div>
                    <div class="nav-subgroup collapsed">
                        <a href="DENCLUE.html" class="nav-item sub">2D</a>
                        <a href="DENCLUE3D.html" class="nav-item sub">3D</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        {
            const saved = localStorage.getItem('sidebarState');
            if (saved) {
                const state = JSON.parse(saved);
                const categoryHeader = document.querySelector('.nav-category-header');
                const subcategory = categoryHeader.nextElementSibling;
                const subheaders = document.querySelectorAll('.nav-subheader');
                
                if (state.category) {
                    categoryHeader.classList.remove('collapsed');
                    subcategory.classList.remove('collapsed');
                }
                if (state.dbscan) {
                    subheaders[0].classList.remove('collapsed');
                    subheaders[0].nextElementSibling.classList.remove('collapsed');
                }
                if (state.hdbscan) {
                    subheaders[1].classList.remove('collapsed');
                    subheaders[1].nextElementSibling.classList.remove('collapsed');
                }
                if (state.optics) {
                    subheaders[2].classList.remove('collapsed');
                    subheaders[2].nextElementSibling.classList.remove('collapsed');
                }
                if (state.denclue) {
                    subheaders[3].classList.remove('collapsed');
                    subheaders[3].nextElementSibling.classList.remove('collapsed');
                }
            }
        }
        
        restoreSidebarState();
    </script>
    
    <div class="main-content">
        <h1 class="main-title">OPTICS Clustering</h1>
        <p class="subtitle">Ordering Points To Identify the Clustering Structure with reachability visualization</p>
    
    <div class="controls-container">
        <div class="control-group">
            <h3>Dataset</h3>
            <div class="control-item">
                <label for="dataset-select">Select Dataset:</label>
                <select id="dataset-select">
                    <option value="0">Two Moons</option>
                    <option value="1">Blobs with Noise</option>
                    <option value="2">Uneven Density</option>
                    <option value="custom">Custom CSV Data</option>
                </select>
            </div>
            <div class="control-item">
                <div class="csv-upload">
                    <input type="file" id="file-input" accept=".csv" onchange="loadCSV(event)">
                    <label for="file-input" class="csv-upload-label">üìÅ Upload CSV</label>
                </div>
            </div>
        </div>
        
        <div class="control-group csv-format">
            <div class="csv-glow-1"></div>
            <div class="csv-glow-2"></div>
            <div class="csv-info-card">
                <div class="csv-badge">Format</div>
                <div class="csv-title">CSV Upload</div>
                <div class="csv-desc">
                    Two numeric columns required<br>
                    Example: x,y<br>
                    1.0,2.3<br>
                    3.1,4.2
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <h3>OPTICS Parameters</h3>
            <div class="control-item">
                <label for="min-samples">Min Samples:</label>
                <input type="number" id="min-samples" value="5" min="2" max="20" onchange="runOPTICS()">
            </div>
            <div class="control-item">
                <label for="max-eps">Max Epsilon:</label>
                <input type="number" id="max-eps" value="2.0" min="0.5" max="10" step="0.5" onchange="runOPTICS()">
            </div>
        </div>
        
        <div class="control-group">
            <h3>Actions</h3>
            <button class="btn" style="width: 100%; display: block; margin-bottom: 10px;" onclick="generateNewData()">Generate New Data</button>
            <button class="btn" style="width: 100%; display: block; margin-bottom: 10px;" onclick="exportResults()">Export Results</button>
            <button class="btn" style="width: 100%; display: block;" onclick="downloadPlot()">Download Plot</button>
        </div>
    </div>
    
    <div class="stats-container">
        <h3>OPTICS Statistics</h3>
        <div class="stats-grid">
            <div class="stat-item">
                <span class="stat-value" id="total-points-metric">-</span>
                <div class="stat-label">Total Points</div>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="ordered-points-metric">-</span>
                <div class="stat-label">Ordered Points</div>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="max-reach-metric">-</span>
                <div class="stat-label">Max Reachability</div>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="clusters-metric">-</span>
                <div class="stat-label">Clusters Found</div>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="silhouette-metric">-</span>
                <div class="stat-label">Silhouette Score</div>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="dbcv-metric">-</span>
                <div class="stat-label">DBCV Score</div>
            </div>
        </div>
    </div>
    
    <div class="plots-container">
        <div class="plot-wrapper">
            <h3>Original Data</h3>
            <div id="original-plot"></div>
        </div>
        <div class="plot-wrapper">
            <h3>Reachability Plot</h3>
            <div id="reachability-plot"></div>
        </div>
    </div>
    
    <div class="plots-container">
        <div class="plot-wrapper">
            <h3>Core Distance</h3>
            <div id="core-distance-plot"></div>
        </div>
        <div class="plot-wrapper">
            <h3>OPTICS Ordering</h3>
            <div id="ordering-plot"></div>
        </div>
    </div>
    
    <div class="plots-container">
        <div class="plot-wrapper" style="flex: 1 1 100%;">
            <h3>Cluster Labels (Threshold: <span id="cluster-threshold-display">0.5</span>)</h3>
            <div class="control-item" style="margin-bottom: 20px;">
                <label for="threshold">Cluster Threshold: <span id="threshold-value">0.5</span></label>
                <input type="range" id="threshold" value="0.5" min="0.1" max="2" step="0.05" oninput="updateThreshold()" style="width: 100%;">
            </div>
            <div id="cluster-plot"></div>
        </div>
    </div>

<script>
    class OPTICS {
        constructor(minSamples = 5, maxEps = Infinity) {
            this.minSamples = minSamples;
            this.maxEps = maxEps;
            this.ordering = [];
            this.reachability = [];
            this.coreDistances = [];
        }

        fit(X) {
            const n = X.length;
            const processed = new Array(n).fill(false);
            this.ordering = [];
            this.reachability = [];
            this.coreDistances = new Array(n);

            for (let i = 0; i < n; i++) {
                this.coreDistances[i] = this.getCoreDistance(X, i);
            }

            for (let i = 0; i < n; i++) {
                if (!processed[i]) {
                    this.expandClusterOrder(X, i, processed);
                }
            }

            return this;
        }

        distance(a, b) {
            return Math.hypot(a[0] - b[0], a[1] - b[1]);
        }

        getCoreDistance(X, idx) {
            const distances = [];
            for (let j = 0; j < X.length; j++) {
                if (j !== idx) {
                    const dist = this.distance(X[idx], X[j]);
                    if (dist <= this.maxEps) {
                        distances.push(dist);
                    }
                }
            }
            distances.sort((a, b) => a - b);
            return distances.length >= this.minSamples - 1 ? distances[this.minSamples - 2] : Infinity;
        }

        expandClusterOrder(X, idx, processed) {
            const seeds = [];
            processed[idx] = true;
            this.ordering.push(idx);
            this.reachability.push(Infinity);

            const neighbors = this.getNeighbors(X, idx);
            if (this.coreDistances[idx] !== Infinity) {
                this.updateSeeds(X, idx, neighbors, seeds, processed);
                
                while (seeds.length > 0) {
                    seeds.sort((a, b) => a.reachDist - b.reachDist);
                    const current = seeds.shift();
                    
                    if (!processed[current.idx]) {
                        processed[current.idx] = true;
                        this.ordering.push(current.idx);
                        this.reachability.push(current.reachDist);
                        
                        const currentNeighbors = this.getNeighbors(X, current.idx);
                        if (this.coreDistances[current.idx] !== Infinity) {
                            this.updateSeeds(X, current.idx, currentNeighbors, seeds, processed);
                        }
                    }
                }
            }
        }

        getNeighbors(X, idx) {
            const neighbors = [];
            for (let j = 0; j < X.length; j++) {
                if (j !== idx) {
                    const dist = this.distance(X[idx], X[j]);
                    if (dist <= this.maxEps) {
                        neighbors.push({ idx: j, dist: dist });
                    }
                }
            }
            return neighbors;
        }

        updateSeeds(X, centerIdx, neighbors, seeds, processed) {
            const coreDist = this.coreDistances[centerIdx];
            
            for (const neighbor of neighbors) {
                if (!processed[neighbor.idx]) {
                    const newReachDist = Math.max(coreDist, neighbor.dist);
                    
                    const existingIdx = seeds.findIndex(s => s.idx === neighbor.idx);
                    if (existingIdx === -1) {
                        seeds.push({ idx: neighbor.idx, reachDist: newReachDist });
                    } else if (newReachDist < seeds[existingIdx].reachDist) {
                        seeds[existingIdx].reachDist = newReachDist;
                    }
                }
            }
        }
    }

    function generateTwoMoons() {
        const data = [];
        for (let i = 0; i < 150; i++) {
            const t = Math.PI * Math.random();
            data.push([Math.cos(t) + 0.1 * (Math.random() - 0.5),
                       Math.sin(t) + 0.1 * (Math.random() - 0.5)]);
        }
        for (let i = 0; i < 150; i++) {
            const t = Math.PI * Math.random();
            data.push([1 - Math.cos(t) + 0.1 * (Math.random() - 0.5),
                       0.5 - Math.sin(t) + 0.1 * (Math.random() - 0.5)]);
        }
        return data;
    }

    function generateBlobs() {
        const data = [], centers = [[2,2],[-2,-2],[2,-2]];
        centers.forEach(c => {
            for (let i = 0; i < 100; i++)
                data.push([c[0] + (Math.random() - 0.5) * 2, c[1] + (Math.random() - 0.5) * 2]);
        });
        for (let i = 0; i < 20; i++)
            data.push([Math.random()*8 - 4, Math.random()*8 - 4]);
        return data;
    }

    function generateUnevenDensity() {
        const data = [];
        for (let i = 0; i < 150; i++) data.push([(Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6]);
        for (let i = 0; i < 100; i++) data.push([3+(Math.random()-0.5)*2, 3+(Math.random()-0.5)*2]);
        for (let i = 0; i < 50; i++) data.push([6+(Math.random()-0.5)*1, (Math.random()-0.5)*1]);
        return data;
    }

    const datasets = [generateTwoMoons(), generateBlobs(), generateUnevenDensity()];
    let customData = null;

    function standardizeData(data) {
        const n = data.length;
        const meanX = data.reduce((s, p) => s + p[0], 0) / n;
        const meanY = data.reduce((s, p) => s + p[1], 0) / n;
        const stdX = Math.sqrt(data.reduce((s, p) => s + Math.pow(p[0]-meanX,2), 0) / n);
        const stdY = Math.sqrt(data.reduce((s, p) => s + Math.pow(p[1]-meanY,2), 0) / n);
        return data.map(p => [(p[0]-meanX)/stdX, (p[1]-meanY)/stdY]);
    }

    function runOPTICS() {
        const ds = document.getElementById('dataset-select').value;
        const minSamples = parseInt(document.getElementById('min-samples').value);
        const maxEps = parseFloat(document.getElementById('max-eps').value);

        let data = ds === 'custom' ? customData : datasets[parseInt(ds)];
        if (!data) return;
        
        data = standardizeData(data);
        const optics = new OPTICS(minSamples, maxEps).fit(data);

        document.getElementById('total-points-metric').textContent = data.length;
        document.getElementById('ordered-points-metric').textContent = optics.ordering.length;
        const maxReach = Math.max(...optics.reachability.filter(r => r !== Infinity));
        document.getElementById('max-reach-metric').textContent = maxReach.toFixed(3);

        plotResults(data, optics);
    }

    let currentOptics = null;
    let currentData = null;
    
    function plotResults(data, optics) {
        currentOptics = optics;
        currentData = data;
        
        Plotly.newPlot('original-plot', [{
            x: data.map(p=>p[0]), y: data.map(p=>p[1]),
            mode:'markers', type:'scatter', marker:{color:'lightblue',size:6}
        }], {
            paper_bgcolor:'#171717',plot_bgcolor:'#171717',font:{color:'white'},
            xaxis:{gridcolor:'#333'}, yaxis:{gridcolor:'#333'}
        }, {responsive: true});

        const reachPlot = optics.reachability.map(r => r === Infinity ? null : r);
        
        Plotly.newPlot('reachability-plot', [{
            x: Array.from({length: reachPlot.length}, (_, i) => i),
            y: reachPlot,
            mode: 'lines',
            type: 'scatter',
            line: {color: '#dd8448', width: 1},
            fill: 'tozeroy',
            fillcolor: 'rgba(221, 132, 72, 0.3)'
        }], {
            title: 'Reachability Distance',
            paper_bgcolor:'#171717',
            plot_bgcolor:'#171717',
            font:{color:'white'},
            xaxis:{title: 'OPTICS Ordering', gridcolor:'#333'},
            yaxis:{title: 'Reachability Distance', gridcolor:'#333'}
        }, {responsive: true});
        
        const coreDistPlot = optics.ordering.map(idx => optics.coreDistances[idx] === Infinity ? null : optics.coreDistances[idx]);
        
        Plotly.newPlot('core-distance-plot', [{
            x: Array.from({length: coreDistPlot.length}, (_, i) => i),
            y: coreDistPlot,
            mode: 'lines',
            type: 'scatter',
            line: {color: '#4CAF50', width: 1},
            fill: 'tozeroy',
            fillcolor: 'rgba(76, 175, 80, 0.3)'
        }], {
            title: 'Core Distance',
            paper_bgcolor:'#171717',
            plot_bgcolor:'#171717',
            font:{color:'white'},
            xaxis:{title: 'OPTICS Ordering', gridcolor:'#333'},
            yaxis:{title: 'Core Distance', gridcolor:'#333'}
        }, {responsive: true});
        
        const orderedData = optics.ordering.map(idx => data[idx]);
        Plotly.newPlot('ordering-plot', [{
            x: orderedData.map(p=>p[0]),
            y: orderedData.map(p=>p[1]),
            mode: 'markers+lines',
            type: 'scatter',
            marker: {color: '#2196F3', size: 4},
            line: {color: '#2196F3', width: 1}
        }], {
            title: 'OPTICS Ordering Path',
            paper_bgcolor:'#171717',
            plot_bgcolor:'#171717',
            font:{color:'white'},
            xaxis:{gridcolor:'#333'},
            yaxis:{gridcolor:'#333'}
        }, {responsive: true});
        
        updateClusterPlot();
    }
    
    function updateThreshold() {
        const threshold = parseFloat(document.getElementById('threshold').value);
        document.getElementById('threshold-value').textContent = threshold.toFixed(2);
        document.getElementById('cluster-threshold-display').textContent = threshold.toFixed(2);
        updateClusterPlot();
    }
    
    function updateClusterPlot() {
        if (!currentOptics || !currentData) return;
        
        const threshold = parseFloat(document.getElementById('threshold').value);
        const labels = extractClusters(currentOptics, threshold);
        
        const colors = ['#dd8448', '#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B'];
        const uniqueLabels = [...new Set(labels)];
        const traces = [];
        
        uniqueLabels.forEach(label => {
            const indices = labels.map((l, i) => l === label ? i : -1).filter(i => i !== -1);
            const x = indices.map(i => currentData[i][0]);
            const y = indices.map(i => currentData[i][1]);
            
            traces.push({
                x: x,
                y: y,
                mode: 'markers',
                type: 'scatter',
                name: label === -1 ? 'Noise' : `Cluster ${label}`,
                marker: {
                    color: label === -1 ? '#666666' : colors[label % colors.length],
                    size: 8,
                    opacity: 0.8
                }
            });
        });
        
        Plotly.newPlot('cluster-plot', traces, {
            title: `Extracted Clusters (${uniqueLabels.filter(l => l !== -1).length} clusters)`,
            paper_bgcolor:'#171717',
            plot_bgcolor:'#171717',
            font:{color:'white'},
            xaxis:{gridcolor:'#333'},
            yaxis:{gridcolor:'#333'},
            showlegend: true,
            legend: {bgcolor: 'rgba(0,0,0,0)'}
        }, {responsive: true});

        // Update stats: clusters + silhouette + DBCV
        const numClusters = uniqueLabels.filter(l => l !== -1).length;
        document.getElementById('clusters-metric').textContent = numClusters;
        const sil = calculateSilhouette2D(currentData, labels);
        document.getElementById('silhouette-metric').textContent = (sil || 0).toFixed(3);
        const dbcv = calculateDBCV2D(currentData, labels);
        document.getElementById('dbcv-metric').textContent = (dbcv || 0).toFixed(3);
    }
    
    function calculateDBCV2D(data, labels) {
        const clusters = [...new Set(labels)].filter(l => l !== -1);
        if (clusters.length < 2) return -1;
        
        const minSamples = 5; // for core point definition
        const eps = estimateEps(data, minSamples);
        if (!eps || eps === Infinity) return -1;
        
        // Calculate density separation and connectivity
        let separationSum = 0, connectivitySum = 0;
        let validClusters = 0;
        
        for (const c of clusters) {
            const clusterPoints = data.filter((_, i) => labels[i] === c);
            if (clusterPoints.length < minSamples) continue;
            
            // Density separation: min distance to other clusters
            let minSep = Infinity;
            for (const otherC of clusters) {
                if (otherC === c) continue;
                const otherPoints = data.filter((_, i) => labels[i] === otherC);
                for (const p1 of clusterPoints) {
                    for (const p2 of otherPoints) {
                        const d = Math.hypot(p1[0]-p2[0], p1[1]-p2[1]);
                        if (d < minSep) minSep = d;
                    }
                }
            }
            
            // Density connectivity: average reachability within cluster
            let connSum = 0, connCount = 0;
            for (let i = 0; i < clusterPoints.length; i++) {
                const neighbors = [];
                for (let j = 0; j < clusterPoints.length; j++) {
                    if (i !== j) {
                        const d = Math.hypot(clusterPoints[i][0]-clusterPoints[j][0], clusterPoints[i][1]-clusterPoints[j][1]);
                        if (d <= eps) neighbors.push(d);
                    }
                }
                if (neighbors.length >= minSamples - 1) {
                    neighbors.sort((a,b)=>a-b);
                    connSum += neighbors[Math.min(minSamples-2, neighbors.length-1)];
                    connCount++;
                }
            }
            
            if (minSep !== Infinity && connCount > 0) {
                separationSum += minSep;
                connectivitySum += connSum / connCount;
                validClusters++;
            }
        }
        
        if (validClusters === 0) return -1;
        const avgSep = separationSum / validClusters;
        const avgConn = connectivitySum / validClusters;
        return avgSep > 0 && avgConn > 0 ? (avgSep - avgConn) / Math.max(avgSep, avgConn) : -1;
    }
    
    function estimateEps(data, minSamples) {
        const kth = [];
        for (let i = 0; i < Math.min(data.length, 100); i++) {
            const dists = [];
            for (let j = 0; j < data.length; j++) {
                if (i !== j) dists.push(Math.hypot(data[i][0]-data[j][0], data[i][1]-data[j][1]));
            }
            dists.sort((a,b)=>a-b);
            if (dists.length >= minSamples) kth.push(dists[Math.min(minSamples-1, dists.length-1)]);
        }
        return kth.length > 0 ? kth.reduce((a,b)=>a+b,0) / kth.length : null;
    }

    function calculateSilhouette2D(data, labels) {
        const clusters = [...new Set(labels)].filter(l => l !== -1);
        if (clusters.length < 2) return 0;
        let total = 0, count = 0;
        for (let i = 0; i < data.length; i++) {
            if (labels[i] === -1) continue;
            const same = [];
            for (let j = 0; j < data.length; j++) if (labels[j] === labels[i] && j !== i) same.push(j);
            if (!same.length) continue;
            const a = same.reduce((s,j)=> s + Math.hypot(data[i][0]-data[j][0], data[i][1]-data[j][1]), 0)/same.length;
            let b = Infinity;
            for (const c of clusters) {
                if (c === labels[i]) continue;
                const other = [];
                for (let j = 0; j < data.length; j++) if (labels[j] === c) other.push(j);
                if (!other.length) continue;
                const d = other.reduce((s,j)=> s + Math.hypot(data[i][0]-data[j][0], data[i][1]-data[j][1]), 0)/other.length;
                if (d < b) b = d;
            }
            if (b !== Infinity) { total += (b - a) / Math.max(a, b); count++; }
        }
        return count ? total / count : 0;
    }
    
    function extractClusters(optics, threshold) {
        const n = optics.ordering.length;
        const labels = new Array(n).fill(-1);
        let clusterId = 0;
        
        for (let i = 0; i < n; i++) {
            if (optics.reachability[i] === Infinity || optics.reachability[i] > threshold) {
                if (i > 0 && labels[i-1] !== -1) {
                    clusterId++;
                }
            } else {
                labels[i] = clusterId;
            }
        }
        
        const finalLabels = new Array(currentData.length).fill(-1);
        for (let i = 0; i < n; i++) {
            finalLabels[optics.ordering[i]] = labels[i];
        }
        
        return finalLabels;
    }

    document.getElementById('dataset-select').addEventListener('change', runOPTICS);

    function loadCSV(event) {
        const file = event.target.files[0];
        if(!file) return;
        processCSVFile(file);
    }
    
    function processCSVFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const csv = e.target.result;
            const lines = csv.split('\n').filter(line => line.trim());
            const data = [];
            
            for(let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => parseFloat(v.trim()));
                if(values.length >= 2 && !isNaN(values[0]) && !isNaN(values[1])) {
                    data.push([values[0], values[1]]);
                }
            }
            
            if(data.length > 0) {
                customData = data;
                document.getElementById('dataset-select').value = 'custom';
                runOPTICS();
            }
        };
        reader.readAsText(file);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const uploadLabel = document.querySelector('label[for="file-input"]');
        
        uploadLabel.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadLabel.style.borderColor = '#dd8448';
            uploadLabel.style.backgroundColor = '#3d3d3d';
        });
        
        uploadLabel.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadLabel.style.borderColor = '#444';
            uploadLabel.style.backgroundColor = '#2d2d2d';
        });
        
        uploadLabel.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadLabel.style.borderColor = '#444';
            uploadLabel.style.backgroundColor = '#2d2d2d';
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processCSVFile(files[0]);
            }
        });
    });

    function exportResults() {
        const ds = document.getElementById('dataset-select').value;
        let data = ds === 'custom' ? customData : datasets[parseInt(ds)];
        if (!data) {
            alert('No data to export!');
            return;
        }
        
        data = standardizeData(data);
        const optics = new OPTICS(
            parseInt(document.getElementById('min-samples').value),
            parseFloat(document.getElementById('max-eps').value)
        ).fit(data);
        
        let csv = 'X,Y,Order,Reachability\n';
        for(let i = 0; i < optics.ordering.length; i++) {
            const idx = optics.ordering[i];
            csv += `${data[idx][0]},${data[idx][1]},${i},${optics.reachability[i]}\n`;
        }
        
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'optics_results.csv';
        a.click();
        window.URL.revokeObjectURL(url);
    }
    
    function generateNewData() {
        const select = document.getElementById('dataset-select');
        const currentIndex = parseInt(select.value);
        const newIndex = (currentIndex + 1) % 3;
        select.value = newIndex.toString();
        runOPTICS();
    }
    
    function downloadPlot() {
        Plotly.downloadImage('reachability-plot', {
            format: 'png',
            width: 1200,
            height: 800,
            filename: 'optics_reachability'
        });
    }
    
    runOPTICS();
</script>
    </div>
<script src="../sidebar.js"></script>`n</body>
</html>


